lesson:
  number: 3
  title: "Binary & Hexadecimal"
  subtitle: "Understanding the language computers speak"
  video_url: "https://www.youtube.com/embed/dQw4w9WgXcQ"

sections:
  - title: "ÔøΩ Why Do We Need Different Number Systems?"
    content: |
      When you program the Atari 2600, you're talking directly to the hardware. Computers don't understand decimal numbers (0-9) like we do‚Äîthey only understand electricity being ON or OFF. That's where binary comes in!
      
      But binary numbers get really long and hard to read, so programmers invented hexadecimal as a shorthand. Think of it like this:
    list:
      - "**Decimal** (base 10): What humans naturally use (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)"
      - "**Binary** (base 2): What computers actually use (just 0 and 1)"
      - "**Hexadecimal** (base 16): A convenient shorthand for programmers"
    content_after: |
      By the end of this lesson, you'll be fluent in all three!

  - title: "üí° Binary: The Language of ON and OFF"
    content: |
      Binary is the most fundamental number system in computing. It only has two digits: **0** (OFF) and **1** (ON). Every number, letter, color, and sound in the Atari 2600 is ultimately represented as a series of 0s and 1s.
      
      **How Binary Counting Works:**
      
      In decimal, each position is worth 10 times more than the one to its right (1, 10, 100, 1000...). In binary, each position is worth 2 times more (1, 2, 4, 8, 16, 32, 64, 128...).
      
      Let's count in binary from 0 to 15:
    list:
      - "0000 = 0 (all switches OFF)"
      - "0001 = 1 (only the 1s place is ON)"
      - "0010 = 2 (only the 2s place is ON)"
      - "0011 = 3 (2 + 1 = 3)"
      - "0100 = 4 (only the 4s place is ON)"
      - "0101 = 5 (4 + 1 = 5)"
      - "0110 = 6 (4 + 2 = 6)"
      - "0111 = 7 (4 + 2 + 1 = 7)"
      - "1000 = 8 (only the 8s place is ON)"
      - "1001 = 9 (8 + 1 = 9)"
      - "1010 = 10 (8 + 2 = 10)"
      - "1011 = 11 (8 + 2 + 1 = 11)"
      - "1100 = 12 (8 + 4 = 12)"
      - "1101 = 13 (8 + 4 + 1 = 13)"
      - "1110 = 14 (8 + 4 + 2 = 14)"
      - "1111 = 15 (8 + 4 + 2 + 1 = 15)"

  - title: "üßÆ Converting Binary to Decimal"
    content: |
      To convert any binary number to decimal, just add up the position values where there's a 1.
      
      **Example: What is 10110101 in decimal?**
      
      First, label each position with its value (from right to left):
    code_blocks:
      - language: "text"
        title: "BINARY CONVERSION"
        content: |
          Position:  128  64  32  16   8   4   2   1
          Binary:      1   0   1   1   0   1   0   1
          
          Add the positions with 1s:
          128 + 32 + 16 + 4 + 1 = 181
          
          So 10110101 in binary = 181 in decimal!
    content_after: |
      **Practice:** Try converting 11001100 yourself. (Answer: 128+64+8+4 = 204)

  - title: "üîÑ Converting Decimal to Binary"
    content: |
      To go the other way (decimal to binary), repeatedly divide by 2 and keep track of the remainders.
      
      **Example: Convert 45 to binary**
    code_blocks:
      - language: "text"
        title: "DECIMAL TO BINARY"
        content: |
          45 √∑ 2 = 22 remainder 1   ‚Üê rightmost bit
          22 √∑ 2 = 11 remainder 0
          11 √∑ 2 = 5  remainder 1
           5 √∑ 2 = 2  remainder 1
           2 √∑ 2 = 1  remainder 0
           1 √∑ 2 = 0  remainder 1   ‚Üê leftmost bit
          
          Read the remainders from BOTTOM to TOP: 101101
          
          So 45 in decimal = 00101101 in binary!
          
          Verify: 32 + 8 + 4 + 1 = 45 ‚úì
    content_after: |
      **Quick Tip:** The Atari 2600's 6502 processor works with 8-bit numbers, meaning every number is represented with 8 binary digits (bits). That's why we write binary numbers with leading zeros, like 00101101 instead of just 101101.

  - title: "üéØ Hexadecimal: The Programmer's Shorthand"
    content: |
      Binary numbers get really long really fast. The number 255 in binary is 11111111‚Äîthat's hard to read and easy to miscount! Hexadecimal (or "hex" for short) solves this problem.
      
      Hexadecimal is base 16, which means it has 16 digits: **0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F**
      
      Wait, letters as numbers? Yes! Here's what they mean:
    list:
      - "**A** = 10"
      - "**B** = 11"
      - "**C** = 12"
      - "**D** = 13"
      - "**E** = 14"
      - "**F** = 15"
    content_after: |
      So we can count in hex: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12... 1F, 20...
      
      **Why hex is perfect for computers:** Each hex digit represents exactly 4 binary bits! This makes conversion super easy.

  - title: "üîÄ Converting Between Binary and Hexadecimal"
    content: |
      The beauty of hexadecimal is how cleanly it maps to binary. Every hex digit equals exactly 4 bits.
      
      **The Hex-to-Binary Chart (memorize this!):**
    code_blocks:
      - language: "text"
        title: "HEX ‚Üî BINARY CONVERSION"
        content: |
          HEX    BINARY    DECIMAL
          ---    ------    -------
           0  =  0000   =    0
           1  =  0001   =    1
           2  =  0010   =    2
           3  =  0011   =    3
           4  =  0100   =    4
           5  =  0101   =    5
           6  =  0110   =    6
           7  =  0111   =    7
           8  =  1000   =    8
           9  =  1001   =    9
           A  =  1010   =   10
           B  =  1011   =   11
           C  =  1100   =   12
           D  =  1101   =   13
           E  =  1110   =   14
           F  =  1111   =   15
    content_after: |
      **Example: Convert A7 (hex) to binary**
      
      Just look up each hex digit:
      - A = 1010
      - 7 = 0111
      
      Put them together: **10100111**
      
      **Example: Convert 11010110 (binary) to hex**
      
      Split into groups of 4 from the right:
      - 1101 = D
      - 0110 = 6
      
      Result: **D6**

  - title: "üíª Hexadecimal in Atari Programming"
    content: |
      In 6502 assembly (the language of the Atari 2600), hex numbers are written with a **$** symbol in front. You'll see this everywhere!
    code_blocks:
      - language: "assembly"
        title: "6502 ASSEMBLY EXAMPLES"
        content: |
          ; Different ways to write the same number (decimal 42):
          
          lda #42         ; Decimal notation (no prefix)
          lda #$2A        ; Hexadecimal notation ($ prefix)
          lda #%00101010  ; Binary notation (% prefix)
          
          ; All three lines do exactly the same thing!
          
          ; Common Atari 2600 memory addresses (always in hex):
          
          COLUBK = $09    ; Background color register
          COLUPF = $08    ; Playfield color register
          WSYNC  = $02    ; Wait for horizontal sync
          
          ; Setting a color in hex:
          lda #$1E        ; Bright white color
          sta COLUBK      ; Store in background color
          
          ; Hex is perfect for bit patterns:
          lda #$F0        ; Binary: 11110000 (top 4 bits on)
          lda #$0F        ; Binary: 00001111 (bottom 4 bits on)
          lda #$AA        ; Binary: 10101010 (alternating bits)
          lda #$55        ; Binary: 01010101 (opposite pattern)
    content_after: |
      **Why programmers love hex:** When you see **$FF**, you instantly know it's 11111111 in binary (all bits on) and 255 in decimal. Hex makes patterns obvious!

  - title: "üß† Converting Hexadecimal to Decimal"
    content: |
      Hex uses position values just like decimal and binary. Each position is worth 16 times more than the one to its right.
      
      **Example: Convert $B3 (hex) to decimal**
    code_blocks:
      - language: "text"
        title: "HEX TO DECIMAL"
        content: |
          Position values:  16¬π   16‚Å∞
          Hex digits:        B     3
          
          B = 11 in decimal
          3 = 3 in decimal
          
          (11 √ó 16) + (3 √ó 1) = 176 + 3 = 179
          
          So $B3 = 179 in decimal
    content_after: |
      **For larger numbers:**
      
      **$1F4A** = (1 √ó 4096) + (15 √ó 256) + (4 √ó 16) + (10 √ó 1) = 4096 + 3840 + 64 + 10 = **8010**

  - title: "üé® Real-World Example: Atari Colors"
    content: |
      The Atari 2600 uses hexadecimal to define colors. Each color is a single byte with this format:
    code_blocks:
      - language: "text"
        title: "ATARI COLOR FORMAT"
        content: |
          Binary:      XXXH HLLL
          
          XXX = unused (always 0)
          HH  = hue (color): 00-15
          LLL = luminance (brightness): 000-111
          
          EXAMPLE: Create an orange color
          
          Orange is hue 3, let's use medium brightness (4):
          
          Binary:   000 11 100
          Hex:      $34
          
          In assembly:
          lda #$34        ; Load orange color
          sta COLUP0      ; Set player 0 to orange
    content_after: |
      Now when you see code like `lda #$1E`, you can decode it: hue 1 (gold), luminance 6 (bright) = bright gold!

  - title: "üî¢ Quick Reference: Common Powers"
    content: |
      Memorize these for fast mental math:
    list:
      - "**2‚Å∞ = 1** | 2¬π = 2 | 2¬≤ = 4 | 2¬≥ = 8"
      - "**2‚Å¥ = 16** | 2‚Åµ = 32 | 2‚Å∂ = 64 | 2‚Å∑ = 128"
      - "**2‚Å∏ = 256** (one byte can store 0-255)"
      - "**16¬π = 16** | 16¬≤ = 256 | 16¬≥ = 4096"
      - "**$FF = 255** (all bits on, maximum byte value)"
      - "**$00 = 0** (all bits off, minimum value)"
      - "**$80 = 128** (only the highest bit on)"

  - title: "üìö What You Should Take Away"
    list:
      - "**Binary** uses only 0 and 1, representing ON/OFF states in computer hardware"
      - "Each binary position is worth double the one to its right (1, 2, 4, 8, 16...)"
      - "**Hexadecimal** uses 0-9 and A-F (where A=10, F=15)"
      - "Each hex digit represents exactly 4 binary bits (making conversion easy)"
      - "In 6502 assembly, hex numbers use **$** prefix, binary uses **%** prefix"
      - "The Atari 2600 works with 8-bit numbers (00000000 to 11111111 = $00 to $FF = 0 to 255)"
      - "Hex makes bit patterns obvious: $F0 = 11110000, $AA = 10101010"

  - title: "üéØ Assignment"
    content: |
      Practice these conversions until they become second nature:
    ordered_list:
      - "Convert these binary numbers to decimal: 10011101, 01010101, 11110000"
      - "Convert these decimal numbers to binary: 64, 127, 200"
      - "Convert these hex numbers to binary: $3C, $A5, $FF"
      - "Convert these binary numbers to hex: 11011001, 10101010, 00001111"
      - "Convert these hex numbers to decimal: $7F, $C8, $2A"
      - "What color is $92 in Atari format? (Hint: extract hue and luminance)"

navigation:
  previous:
    title: "Previous: 6502 Assembly"
    url: "lesson.html?id=2"
  next:
    title: "Next: TIA Graphics Chip"
    url: "lesson.html?id=4"